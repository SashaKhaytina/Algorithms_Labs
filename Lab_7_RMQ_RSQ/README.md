# RMQ
## Сравнение скорости разных **Sparce Table** (длинной и высокой) 
### Что сравниваем?
#### Построим 2 разные Sparce Table:

- Длинную - ```Sparse_Table_Longer``` ( $logN \times N$ )
- Высокую - ```Sparse_Table_Higher``` ( $N \times logN$ )

Сравним время ответов на запросы минимума на большом массиве данных.

### Описание тестов
На вход подавался массив случайных чисел типа ```int``` в диапазоне $[1;100000]$ размером $10^6$ элементов. Также падавался массив случайных невырожденных отрезков (подотрезков $[0;10^6]$), на которых нужно было искать минимум. 

### Тесты
Было проведено 5 тестов на разных массивах и отрезках. Построим таблицу результатов. 

|                           | Время тест 1, мс | Время Тест 2, мс | Время Тест 3, мс | Время Тест 4, мс | Время Тест 5, мс | Среднее время, мс|
|:-----:                    |:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
| ```Sparse_Table_Longer``` |    $44$   |    $43$    |    $48$    |    $52$    |    $49$    |    $47.2$    |
| ```Sparse_Table_Higher``` |    $90$    |    $88$    |    $86$    |    $84$    |    $87$    |    $87$    |


По таблице результатов видно, что "длинная" sparse table работает заметно быстрее, почти в 2 раза.  

### С чем может быть связвна разница во времени?

Выигрыш ```Sparse_Table_Longer``` может быть связан с ее более подходящим устроиством для работы с кешами. При запросе на минимум в "длинной таблице" мы будем брать минимум у элементов в одном массиве (строке таблицы) (то есть обращение к элементам одного массива). А у ```Sparse_Table_Higher``` мы будем брать их из одного столбца таблицы, а это 2 разных массива (так как 1 массив = 1 строка). ```Sparse_Table_Longer``` более _cache-friendly_, поэтому она работает быстрее. 